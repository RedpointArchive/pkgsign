import test from 'ava';
import * as fs from 'fs';
import * as path from 'path';
import SignCommand, { SignOptions } from '../src/commands/sign';
import VerifyCommand, { VerifyOptions } from '../src/commands/verify';
import { readFilePromise } from '../src/lib/fsPromise';

process.chdir(__dirname);

async function sign(testName: string): Promise<boolean> {
  const cmd = new SignCommand();
  const opts = new SignOptions();
  opts.withSigner = 'pgp';
  opts.privateKeyPath = path.join(__dirname, 'test.key');
  opts.privateKeyPassphrase = '';
  opts.publicKeyUrl = 'https://pkgsign.test.invalid.url/test.pub';
  return await cmd.executeInternal(testName, opts);
}

async function verify(testName: string): Promise<boolean> {
  const cmd = new VerifyCommand();
  const opts = new VerifyOptions();
  opts.nonInteractive = true;
  opts.full = false;
  opts.packageName = testName;
  opts.enableTestTrustStore = true;
  return await cmd.executeInternal(testName, opts);
}

test('signature has packageJson entry present', async t => {
  const testName = 'signature-has-packageJson-entry-present';
  t.true(await sign(testName));
  t.true(fs.existsSync(path.join(testName, 'signature.json')), 'signature.json is not present');
  const json = JSON.parse(await readFilePromise(path.join(testName, 'signature.json')));
  t.true(json.entries.some(entry => entry.entry === 'packageJson/v1alpha1'));
  t.true(json.entries.some(entry => entry.entry === 'npmCompatiblePackageJson/v1alpha1'));
});

test('signature packageJson omits NPM fields on sign', async t => {
  const testName = 'signature-packageJson-omits-npm-on-sign';
  t.true(await sign(testName));
  t.true(fs.existsSync(path.join(testName, 'signature.json')), 'signature.json is not present');
  const json = JSON.parse(await readFilePromise(path.join(testName, 'signature.json')));
  t.true(json.entries.some(entry => entry.entry === 'npmCompatiblePackageJson/v1alpha1'));
  t.true(json.entries.some(entry => entry.entry === 'packageJson/v1alpha1'));
  
  const npmCompatibleEntry = json.entries.filter(entry => entry.entry === 'npmCompatiblePackageJson/v1alpha1')[0];
  const packageJsonEntry = json.entries.filter(entry => entry.entry === 'packageJson/v1alpha1')[0];
  
  t.is(npmCompatibleEntry.packageJsonProperties.sort().indexOf('_from'), -1, 'signature.json npmCompatiblePackageJson/v1alpha1 contains _from property');
  t.is(Object.keys(packageJsonEntry.packageJson).sort().indexOf('_from'), -1, 'signature.json packageJson/v1alpha1 contains _from property');
});

test('signature packageJson omits NPM fields on verify', async t => {
  const testName = 'signature-packageJson-omits-npm-on-verify';
  t.true(await verify(testName));
});

test('check signature of package', async t => {
  const testName = 'npm-published/regular-pkg';
  
  // sign test package
  t.true(await sign(testName));
  const originalPackageSignature = JSON.parse(await readFilePromise(path.join(testName, 'signature.json')));
  const originalPackageJson = JSON.parse(await readFilePromise(path.join(testName, 'package.json')));

  t.true(originalPackageSignature.entries.some(entry => entry.entry === 'files/v1alpha1'));
  t.true(originalPackageSignature.entries.some(entry => entry.entry === 'identity/v1alpha1'));
  t.true(originalPackageSignature.entries.some(entry => entry.entry === 'packageJson/v1alpha1'));
  t.true(originalPackageSignature.entries.some(entry => entry.entry === 'npmCompatiblePackageJson/v1alpha1'));

  // all files ignored, except the files in the resulting package
  const filesEntry = originalPackageSignature.entries.filter(entry => entry.entry === 'files/v1alpha1')[0];
  t.is(filesEntry.files.length, 2, 'signature.json files/v1alpha1 has only 2 files');
  t.true(filesEntry.files.some(entry => entry.path === 'dist/index.js'));
  t.true(filesEntry.files.some(entry => entry.path === 'README.md'));

  // all properties ignored, starting with underscore
  const npmCompatibleEntry = originalPackageSignature.entries.filter(entry => entry.entry === 'npmCompatiblePackageJson/v1alpha1')[0];
  t.is(npmCompatibleEntry.packageJsonProperties.sort().indexOf('_ignored'), -1, 'signature.json npmCompatiblePackageJson/v1alpha1 contains _ignored property');
  
  const packageJsonEntry = originalPackageSignature.entries.filter(entry => entry.entry === 'packageJson/v1alpha1')[0];
  t.deepEqual(packageJsonEntry.packageJson, originalPackageJson, 'packageJson of packageJson/v1alpha1 doesn\'t match package.json from package');
  
  const installedPackageJson = JSON.parse(await readFilePromise(path.join('npm-installed/regular-pkg', 'package.json')));
  // check for install metadata properties
  t.true(Object.keys(installedPackageJson).some(entry => entry.indexOf('_') === 0));
  // check for autogenerated description from readme.md
  t.true(Object.keys(installedPackageJson).some(entry => entry.localeCompare('description') === 0));
  t.is(installedPackageJson.description, 'original example package as seen in any git repository',
        'package.json of installed package does not have auto-generated description field');
});

test('verify valid signature of installed package', async t => {
  // the verification should only take into account the properties
  // directly set by the developer / package-owner
  t.true(await verify('npm-installed/regular-pkg'));
});

test('fail verification on manipulated package content', async t => {
  // should fail to verify modified package.json
  t.false(await verify('npm-installed/regular-pkg-packageJson-modified'));
  
  // should fail to verify modified code
  t.false(await verify('npm-installed/regular-pkg-code-modified'));
});
